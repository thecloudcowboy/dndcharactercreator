"use strict";
/**
 * UI utilities module for R1 display optimization
 * Provides tools for 240x282px display, hardware-accelerated CSS, and DOM optimization
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ui = exports.R1UI = exports.R1Component = exports.PerformanceUtils = exports.LayoutUtils = exports.DOMUtils = exports.CSSUtils = exports.R1_DIMENSIONS = void 0;
exports.R1_DIMENSIONS = {
    width: 240,
    height: 282
};
/**
 * CSS utilities for hardware-accelerated animations and R1 optimization
 */
class CSSUtils {
    /**
     * Apply hardware-accelerated transform
     * @param element Target element
     * @param transform Transform value (e.g., 'translateX(10px)')
     */
    static setTransform(element, transform) {
        element.style.transform = transform;
        element.style.willChange = 'transform';
    }
    /**
     * Apply hardware-accelerated opacity
     * @param element Target element
     * @param opacity Opacity value (0-1)
     */
    static setOpacity(element, opacity) {
        element.style.opacity = opacity.toString();
        element.style.willChange = 'opacity';
    }
    /**
     * Reset will-change property to optimize performance
     * @param element Target element
     */
    static resetWillChange(element) {
        element.style.willChange = 'auto';
    }
    /**
     * Add hardware-accelerated transition
     * @param element Target element
     * @param property CSS property to transition
     * @param duration Duration in milliseconds
     * @param easing Easing function (default: ease-out)
     */
    static addTransition(element, property, duration, easing = 'ease-out') {
        element.style.transition = `${property} ${duration}ms ${easing}`;
    }
    /**
     * Create optimized CSS animation class
     * @param name Animation name
     * @param keyframes CSS keyframes
     * @param duration Duration in milliseconds
     * @param easing Easing function
     */
    static createAnimation(name, keyframes, duration, easing = 'ease-out') {
        const style = document.createElement('style');
        style.textContent = `
      @keyframes ${name} {
        ${keyframes}
      }
      .${name} {
        animation: ${name} ${duration}ms ${easing};
      }
    `;
        document.head.appendChild(style);
    }
}
exports.CSSUtils = CSSUtils;
/**
 * DOM optimization utilities for minimal DOM changes
 */
class DOMUtils {
    /**
     * Batch DOM operations using DocumentFragment
     * @param operations Function containing DOM operations
     * @param container Container element to append fragment to
     */
    static batchOperations(operations, container) {
        const fragment = document.createDocumentFragment();
        operations(fragment);
        container.appendChild(fragment);
    }
    /**
     * Efficiently update element content without full innerHTML replacement
     * @param element Target element
     * @param content New content
     */
    static updateContent(element, content) {
        if (element.textContent !== content) {
            element.textContent = content;
        }
    }
    /**
     * Toggle class efficiently
     * @param element Target element
     * @param className Class name to toggle
     * @param condition Optional condition for toggle
     */
    static toggleClass(element, className, condition) {
        if (condition !== undefined) {
            element.classList.toggle(className, condition);
        }
        else {
            element.classList.toggle(className);
        }
    }
    /**
     * Create element with optimized attributes
     * @param tagName Element tag name
     * @param attributes Element attributes
     * @param textContent Optional text content
     */
    static createElement(tagName, attributes = {}, textContent) {
        const element = document.createElement(tagName);
        Object.entries(attributes).forEach(([key, value]) => {
            element.setAttribute(key, value);
        });
        if (textContent !== undefined) {
            element.textContent = textContent;
        }
        return element;
    }
    /**
     * Debounce function for reducing DOM updates
     * @param func Function to debounce
     * @param delay Delay in milliseconds
     */
    static debounce(func, delay) {
        let timeoutId;
        return ((...args) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => func.apply(null, args), delay);
        });
    }
}
exports.DOMUtils = DOMUtils;
DOMUtils.documentFragment = null;
/**
 * Layout utilities for R1 display
 */
class LayoutUtils {
    /**
     * Check if coordinates are within R1 display bounds
     * @param x X coordinate
     * @param y Y coordinate
     */
    static isWithinBounds(x, y) {
        return x >= 0 && x <= exports.R1_DIMENSIONS.width && y >= 0 && y <= exports.R1_DIMENSIONS.height;
    }
    /**
     * Clamp coordinates to R1 display bounds
     * @param x X coordinate
     * @param y Y coordinate
     */
    static clampToBounds(x, y) {
        return {
            x: Math.max(0, Math.min(x, exports.R1_DIMENSIONS.width)),
            y: Math.max(0, Math.min(y, exports.R1_DIMENSIONS.height))
        };
    }
    /**
     * Calculate responsive font size based on container
     * @param containerWidth Container width
     * @param baseSize Base font size in px
     * @param minSize Minimum font size in px
     * @param maxSize Maximum font size in px
     */
    static calculateFontSize(containerWidth, baseSize = 16, minSize = 12, maxSize = 24) {
        const ratio = containerWidth / exports.R1_DIMENSIONS.width;
        const scaledSize = baseSize * ratio;
        return Math.max(minSize, Math.min(scaledSize, maxSize));
    }
    /**
     * Create CSS for R1-optimized container
     */
    static createR1Container() {
        return `
      width: ${exports.R1_DIMENSIONS.width}px;
      height: ${exports.R1_DIMENSIONS.height}px;
      max-width: 100vw;
      max-height: 100vh;
      overflow: hidden;
      position: relative;
      box-sizing: border-box;
    `;
    }
    /**
     * Apply R1 container styles to element
     * @param element Target element
     */
    static applyR1Container(element) {
        Object.assign(element.style, {
            width: `${exports.R1_DIMENSIONS.width}px`,
            height: `${exports.R1_DIMENSIONS.height}px`,
            maxWidth: '100vw',
            maxHeight: '100vh',
            overflow: 'hidden',
            position: 'relative',
            boxSizing: 'border-box'
        });
    }
}
exports.LayoutUtils = LayoutUtils;
/**
 * Performance monitoring utilities
 */
class PerformanceUtils {
    /**
     * Start performance measurement
     * @param name Measurement name
     */
    static startMeasure(name) {
        this.performanceMarks.set(name, performance.now());
    }
    /**
     * End performance measurement and log result
     * @param name Measurement name
     * @param logToConsole Whether to log to console
     */
    static endMeasure(name, logToConsole = true) {
        const startTime = this.performanceMarks.get(name);
        if (!startTime) {
            console.warn(`No start mark found for: ${name}`);
            return 0;
        }
        const duration = performance.now() - startTime;
        this.performanceMarks.delete(name);
        if (logToConsole) {
            console.log(`Performance [${name}]: ${duration.toFixed(2)}ms`);
        }
        return duration;
    }
    /**
     * Monitor frame rate
     * @param duration Duration to monitor in seconds
     * @param callback Callback with average FPS
     */
    static monitorFPS(duration, callback) {
        let frames = 0;
        const startTime = performance.now();
        const tick = () => {
            frames++;
            const currentTime = performance.now();
            const elapsed = (currentTime - startTime) / 1000;
            if (elapsed >= duration) {
                const fps = frames / elapsed;
                callback(fps);
            }
            else {
                requestAnimationFrame(tick);
            }
        };
        requestAnimationFrame(tick);
    }
}
exports.PerformanceUtils = PerformanceUtils;
PerformanceUtils.performanceMarks = new Map();
/**
 * R1 UI Component base class
 */
class R1Component {
    constructor(tagName = 'div', className) {
        this.mounted = false;
        this.element = document.createElement(tagName);
        if (className) {
            this.element.className = className;
        }
    }
    /**
     * Mount component to container
     * @param container Container element
     */
    mount(container) {
        if (this.mounted) {
            console.warn('Component already mounted');
            return;
        }
        container.appendChild(this.element);
        this.mounted = true;
        this.onMount();
    }
    /**
     * Unmount component
     */
    unmount() {
        if (!this.mounted)
            return;
        if (this.element.parentNode) {
            this.element.parentNode.removeChild(this.element);
        }
        this.mounted = false;
        this.onUnmount();
    }
    /**
     * Get component element
     */
    getElement() {
        return this.element;
    }
    /**
     * Check if component is mounted
     */
    isMounted() {
        return this.mounted;
    }
}
exports.R1Component = R1Component;
/**
 * UI design utilities for R1 device (responsive design system)
 */
class R1UI {
    constructor() {
        this.screenWidth = 240;
        this.screenHeight = 282;
        this.aspectRatio = this.screenHeight / this.screenWidth;
        this.baseUnit = 'vw';
    }
    /**
     * Get screen dimensions
     */
    get dimensions() {
        return {
            width: 240,
            height: 282
        };
    }
    /**
     * Convert pixels to viewport width units
     * @param px Pixel value
     */
    pxToVw(px) {
        return `${(px / this.screenWidth) * 100}${this.baseUnit}`;
    }
    /**
     * Get responsive font sizes
     */
    getFontSizes() {
        return {
            title: '12.5vw', // ~30px on 240px width
            large: '10vw', // ~24px
            body: '8.33vw', // ~20px
            small: '6.25vw', // ~15px
            tiny: '5vw' // ~12px
        };
    }
    /**
     * Get spacing values
     */
    getSpacing() {
        return {
            xs: '1.25vw', // ~3px on 240px width
            sm: '2.5vw', // ~6px
            md: '3.33vw', // ~8px
            lg: '5vw', // ~12px
            xl: '7.5vw', // ~18px
            xxl: '10vw' // ~24px
        };
    }
    /**
     * Get button dimensions
     */
    getButtonSizes() {
        return {
            wide: {
                width: '80vw', // ~192px on 240px width
                height: '15vw', // ~36px
                fontSize: '8.33vw'
            },
            standard: {
                width: '45vw', // ~108px on 240px width
                height: '15vw', // ~36px
                fontSize: '8.33vw'
            },
            small: {
                width: '30vw', // ~72px on 240px width
                height: '12vw', // ~29px
                fontSize: '6.25vw'
            },
            round: {
                width: '20vw', // ~48px on 240px width
                height: '20vw', // ~48px
                borderRadius: '50%'
            }
        };
    }
    /**
     * Create a responsive container
     * @param element Container element
     * @param options Container options
     */
    createContainer(element, options = {}) {
        const defaults = {
            width: '100vw',
            height: `${this.aspectRatio * 100}vw`, // Maintains aspect ratio
            background: '#000000',
            padding: this.getSpacing().md
        };
        const settings = { ...defaults, ...options };
        Object.assign(element.style, {
            width: settings.width,
            height: settings.height,
            background: settings.background,
            padding: settings.padding,
            boxSizing: 'border-box',
            position: 'relative',
            overflow: 'hidden'
        });
    }
    /**
     * Create a touch-optimized button
     * @param button Button element
     * @param options Button options
     */
    createButton(button, options = {}) {
        const sizes = this.getButtonSizes();
        const defaults = {
            type: 'wide',
            background: '#FE5F00',
            color: '#FFFFFF',
            borderRadius: '50vw',
            active: true
        };
        const settings = { ...defaults, ...options };
        const size = sizes[settings.type];
        Object.assign(button.style, {
            width: size.width,
            height: size.height,
            fontSize: 'fontSize' in size ? size.fontSize : this.getFontSizes().body,
            background: settings.active ? settings.background : '#333333',
            color: settings.color,
            border: 'none',
            borderRadius: settings.borderRadius,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            cursor: 'pointer',
            fontWeight: 'bold',
            transition: 'all 0.2s ease',
            userSelect: 'none',
            WebkitTapHighlightColor: 'transparent'
        });
        // Add touch feedback
        button.addEventListener('touchstart', () => {
            button.style.transform = 'scale(0.95)';
        });
        button.addEventListener('touchend', () => {
            button.style.transform = 'scale(1)';
        });
    }
    /**
     * Create a responsive text element
     * @param element Text element
     * @param options Text options
     */
    createText(element, options = {}) {
        const fonts = this.getFontSizes();
        const defaults = {
            size: 'body',
            color: '#FFFFFF',
            align: 'center',
            weight: 'normal'
        };
        const settings = { ...defaults, ...options };
        Object.assign(element.style, {
            fontSize: fonts[settings.size],
            color: settings.color,
            textAlign: settings.align,
            fontWeight: settings.weight,
            lineHeight: '1.2',
            margin: '0',
            padding: '0'
        });
    }
    /**
     * Create a layout grid
     * @param container Container element
     * @param options Grid options
     */
    createGrid(container, options = {}) {
        const defaults = {
            columns: 2,
            gap: this.getSpacing().md,
            alignItems: 'center',
            justifyItems: 'center'
        };
        const settings = { ...defaults, ...options };
        Object.assign(container.style, {
            display: 'grid',
            gridTemplateColumns: `repeat(${settings.columns}, 1fr)`,
            gap: settings.gap,
            alignItems: settings.alignItems,
            justifyItems: settings.justifyItems,
            width: '100%',
            height: '100%'
        });
    }
    /**
     * Apply theme colors
     */
    getColors() {
        return {
            background: '#000000',
            primary: '#FE5F00', // Orange
            secondary: '#FFFFFF', // White
            disabled: '#333333', // Dark gray
            text: {
                primary: '#FFFFFF',
                secondary: '#CCCCCC',
                disabled: '#666666'
            },
            status: {
                success: '#00FF00',
                error: '#FF0000',
                warning: '#FFAA00',
                info: '#0099FF'
            }
        };
    }
    /**
     * Apply viewport meta tag for proper scaling
     */
    setupViewport() {
        let viewport = document.querySelector('meta[name="viewport"]');
        if (!viewport) {
            viewport = document.createElement('meta');
            viewport.setAttribute('name', 'viewport');
            document.head.appendChild(viewport);
        }
        viewport.setAttribute('content', 'width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no');
    }
    /**
     * Create animated transition between elements
     * @param fromElement Element to transition from
     * @param toElement Element to transition to
     * @param type Transition type: 'slide', 'fade', or 'none'
     * @param duration Duration in milliseconds
     */
    transition(fromElement, toElement, type = 'slide', duration = 300) {
        switch (type) {
            case 'slide':
                this.slideTransition(fromElement, toElement, duration);
                break;
            case 'fade':
                this.fadeTransition(fromElement, toElement, duration);
                break;
            case 'none':
                fromElement.style.display = 'none';
                toElement.style.display = 'block';
                break;
        }
    }
    /**
     * Slide transition effect
     * @private
     */
    slideTransition(fromElement, toElement, duration) {
        toElement.style.display = 'block';
        toElement.style.transform = 'translateX(100%)';
        toElement.style.transition = `transform ${duration}ms ease-in-out`;
        fromElement.style.transition = `transform ${duration}ms ease-in-out`;
        setTimeout(() => {
            fromElement.style.transform = 'translateX(-100%)';
            toElement.style.transform = 'translateX(0)';
        }, 10);
        setTimeout(() => {
            fromElement.style.display = 'none';
            fromElement.style.transform = '';
            fromElement.style.transition = '';
            toElement.style.transition = '';
        }, duration + 10);
    }
    /**
     * Fade transition effect
     * @private
     */
    fadeTransition(fromElement, toElement, duration) {
        toElement.style.display = 'block';
        toElement.style.opacity = '0';
        toElement.style.transition = `opacity ${duration}ms ease-in-out`;
        fromElement.style.transition = `opacity ${duration}ms ease-in-out`;
        setTimeout(() => {
            fromElement.style.opacity = '0';
            toElement.style.opacity = '1';
        }, 10);
        setTimeout(() => {
            fromElement.style.display = 'none';
            fromElement.style.opacity = '';
            fromElement.style.transition = '';
            toElement.style.transition = '';
        }, duration + 10);
    }
}
exports.R1UI = R1UI;
// Export singleton instance
exports.ui = new R1UI();
//# sourceMappingURL=index.js.map