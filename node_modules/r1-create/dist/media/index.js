"use strict";
/**
 * Media API module for R1 device
 * Provides access to camera, microphone, and speaker using standard web APIs
 * Optimized for R1 hardware limitations and mobile performance
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.speaker = exports.microphone = exports.camera = exports.MediaUtils = exports.SpeakerAPI = exports.MicrophoneAPI = exports.CameraAPI = void 0;
/**
 * Camera API for R1 device
 */
class CameraAPI {
    constructor() {
        this.stream = null;
        this.videoElement = null;
    }
    /**
     * Check if camera is available
     */
    async isAvailable() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            return devices.some(device => device.kind === 'videoinput');
        }
        catch {
            return false;
        }
    }
    /**
     * Start camera stream
     * @param config Video configuration
     */
    async start(config = {}) {
        try {
            const constraints = {
                video: {
                    width: config.width || 240,
                    height: config.height || 282,
                    frameRate: config.frameRate || 30,
                    facingMode: config.facingMode || 'user'
                },
                audio: false
            };
            this.stream = await navigator.mediaDevices.getUserMedia(constraints);
            return this.stream;
        }
        catch (error) {
            throw new Error(`Failed to start camera: ${error}`);
        }
    }
    /**
     * Stop camera stream
     */
    stop() {
        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
            this.stream = null;
        }
        if (this.videoElement) {
            this.videoElement.srcObject = null;
        }
    }
    /**
     * Get camera stream
     */
    getStream() {
        return this.stream;
    }
    /**
     * Create video element with stream
     * @param autoplay Whether to autoplay video
     * @param muted Whether to mute video
     */
    createVideoElement(autoplay = true, muted = true) {
        if (!this.stream) {
            throw new Error('Camera stream not started');
        }
        this.videoElement = document.createElement('video');
        this.videoElement.srcObject = this.stream;
        this.videoElement.autoplay = autoplay;
        this.videoElement.muted = muted;
        this.videoElement.playsInline = true;
        // Optimize for R1 display
        this.videoElement.style.width = '100%';
        this.videoElement.style.height = '100%';
        this.videoElement.style.objectFit = 'cover';
        return this.videoElement;
    }
    /**
     * Capture photo from camera stream
     * @param width Image width (default: 240)
     * @param height Image height (default: 282)
     */
    capturePhoto(width = 240, height = 282) {
        if (!this.videoElement || !this.stream) {
            throw new Error('Camera not started');
        }
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext('2d');
        if (!context)
            return null;
        context.drawImage(this.videoElement, 0, 0, width, height);
        return canvas.toDataURL('image/jpeg', 0.8);
    }
    /**
     * Switch camera (front/back)
     */
    async switchCamera() {
        if (!this.stream) {
            throw new Error('Camera not started');
        }
        const videoTrack = this.stream.getVideoTracks()[0];
        const currentFacingMode = videoTrack.getSettings().facingMode;
        const newFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
        this.stop();
        await this.start({ facingMode: newFacingMode });
    }
}
exports.CameraAPI = CameraAPI;
/**
 * Microphone API for R1 device
 */
class MicrophoneAPI {
    constructor() {
        this.stream = null;
        this.mediaRecorder = null;
        this.recordedChunks = [];
    }
    /**
     * Check if microphone is available
     */
    async isAvailable() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            return devices.some(device => device.kind === 'audioinput');
        }
        catch {
            return false;
        }
    }
    /**
     * Start microphone stream
     * @param config Audio configuration
     */
    async start(config = {}) {
        try {
            const constraints = {
                audio: {
                    sampleRate: config.sampleRate || 44100,
                    channelCount: config.channelCount || 1,
                    echoCancellation: config.echoCancellation ?? true,
                    noiseSuppression: config.noiseSuppression ?? true,
                    autoGainControl: config.autoGainControl ?? true
                }
            };
            this.stream = await navigator.mediaDevices.getUserMedia(constraints);
            return this.stream;
        }
        catch (error) {
            throw new Error(`Failed to start microphone: ${error}`);
        }
    }
    /**
     * Stop microphone stream
     */
    stop() {
        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
            this.stream = null;
        }
        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
            this.mediaRecorder.stop();
        }
    }
    /**
     * Start recording audio
     * @param options Recording options
     */
    async startRecording(options = {}) {
        if (!this.stream) {
            await this.start();
        }
        if (!this.stream) {
            throw new Error('Failed to start microphone stream');
        }
        this.recordedChunks = [];
        this.mediaRecorder = new MediaRecorder(this.stream, {
            mimeType: options.mimeType || 'audio/webm',
            audioBitsPerSecond: options.audioBitsPerSecond || 128000
        });
        this.mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
                this.recordedChunks.push(event.data);
            }
        };
        this.mediaRecorder.start();
    }
    /**
     * Stop recording and get audio blob
     */
    async stopRecording() {
        return new Promise((resolve, reject) => {
            if (!this.mediaRecorder) {
                reject(new Error('Recording not started'));
                return;
            }
            this.mediaRecorder.onstop = () => {
                const blob = new Blob(this.recordedChunks, { type: 'audio/webm' });
                resolve(blob);
            };
            this.mediaRecorder.onerror = (event) => {
                reject(new Error('Recording failed'));
            };
            this.mediaRecorder.stop();
        });
    }
    /**
     * Get current recording state
     */
    getRecordingState() {
        return this.mediaRecorder?.state || 'inactive';
    }
    /**
     * Get audio stream
     */
    getStream() {
        return this.stream;
    }
}
exports.MicrophoneAPI = MicrophoneAPI;
/**
 * Speaker API for R1 device
 */
class SpeakerAPI {
    constructor() {
        this.audioContext = null;
        this.currentAudio = null;
    }
    /**
     * Initialize audio context
     */
    async initializeAudioContext() {
        if (!this.audioContext) {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (this.audioContext.state === 'suspended') {
                await this.audioContext.resume();
            }
        }
    }
    /**
     * Play audio from URL or blob
     * @param source Audio source (URL, blob, or base64)
     * @param volume Volume level (0-1)
     */
    async play(source, volume = 1) {
        await this.initializeAudioContext();
        return new Promise((resolve, reject) => {
            this.currentAudio = new Audio();
            this.currentAudio.volume = Math.max(0, Math.min(1, volume));
            this.currentAudio.onended = () => resolve();
            this.currentAudio.onerror = () => reject(new Error('Audio playback failed'));
            if (source instanceof Blob) {
                this.currentAudio.src = URL.createObjectURL(source);
            }
            else {
                this.currentAudio.src = source;
            }
            this.currentAudio.play().catch(reject);
        });
    }
    /**
     * Stop current audio playback
     */
    stop() {
        if (this.currentAudio) {
            this.currentAudio.pause();
            this.currentAudio.currentTime = 0;
            if (this.currentAudio.src.startsWith('blob:')) {
                URL.revokeObjectURL(this.currentAudio.src);
            }
        }
    }
    /**
     * Set volume for current audio
     * @param volume Volume level (0-1)
     */
    setVolume(volume) {
        if (this.currentAudio) {
            this.currentAudio.volume = Math.max(0, Math.min(1, volume));
        }
    }
    /**
     * Generate and play tone
     * @param frequency Frequency in Hz
     * @param duration Duration in milliseconds
     * @param volume Volume level (0-1)
     */
    async playTone(frequency, duration, volume = 0.5) {
        await this.initializeAudioContext();
        if (!this.audioContext)
            return;
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
        gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + duration / 1000);
        return new Promise(resolve => {
            oscillator.onended = () => resolve();
        });
    }
    /**
     * Check if audio is currently playing
     */
    isPlaying() {
        return this.currentAudio ? !this.currentAudio.paused : false;
    }
}
exports.SpeakerAPI = SpeakerAPI;
/**
 * Media device utilities
 */
class MediaUtils {
    /**
     * Get available media devices
     */
    static async getDevices() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            return devices.map(device => ({
                deviceId: device.deviceId,
                kind: device.kind,
                label: device.label,
                groupId: device.groupId
            }));
        }
        catch {
            return [];
        }
    }
    /**
     * Check if specific media type is supported
     * @param type Media type to check
     */
    static async isSupported(type) {
        switch (type) {
            case 'camera':
                return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
            case 'microphone':
                return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
            case 'speaker':
                return !!(window.AudioContext || window.webkitAudioContext);
            default:
                return false;
        }
    }
    /**
     * Convert blob to base64 string
     * @param blob Blob to convert
     */
    static blobToBase64(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
                const result = reader.result;
                resolve(result.split(',')[1]); // Remove data URL prefix
            };
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    }
    /**
     * Convert base64 string to blob
     * @param base64 Base64 string
     * @param mimeType MIME type
     */
    static base64ToBlob(base64, mimeType) {
        const byteCharacters = atob(base64);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        return new Blob([byteArray], { type: mimeType });
    }
}
exports.MediaUtils = MediaUtils;
// Export singleton instances
exports.camera = new CameraAPI();
exports.microphone = new MicrophoneAPI();
exports.speaker = new SpeakerAPI();
//# sourceMappingURL=index.js.map