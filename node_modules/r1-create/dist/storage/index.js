"use strict";
/**
 * Storage API module for R1 plugin data persistence
 * Provides both plain and secure storage with automatic Base64 encoding
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.storage = exports.R1Storage = exports.Base64Utils = void 0;
/**
 * Utility functions for Base64 encoding/decoding
 */
class Base64Utils {
    /**
     * Encode data to Base64 string
     * @param data Data to encode (string or object)
     */
    static encode(data) {
        const jsonString = typeof data === 'string' ? data : JSON.stringify(data);
        return btoa(jsonString);
    }
    /**
     * Decode Base64 string to data
     * @param encoded Base64 encoded string
     * @param parseJson Whether to parse as JSON (default: true)
     */
    static decode(encoded, parseJson = true) {
        const decoded = atob(encoded);
        return parseJson ? JSON.parse(decoded) : decoded;
    }
    /**
     * Safely decode Base64 string, returns null if invalid
     * @param encoded Base64 encoded string
     * @param parseJson Whether to parse as JSON (default: true)
     */
    static safeDecode(encoded, parseJson = true) {
        if (!encoded)
            return null;
        try {
            const decoded = atob(encoded);
            return parseJson ? JSON.parse(decoded) : decoded;
        }
        catch (error) {
            console.warn('Failed to decode storage data:', error);
            return null;
        }
    }
}
exports.Base64Utils = Base64Utils;
/**
 * Enhanced storage wrapper with automatic Base64 encoding and JSON support
 */
class StorageWrapper {
    constructor(storage) {
        this.storage = storage;
    }
    /**
     * Store data with automatic Base64 encoding
     * @param key Storage key
     * @param value Data to store (will be JSON stringified and Base64 encoded)
     */
    async setItem(key, value) {
        const encoded = Base64Utils.encode(value);
        await this.storage.setItem(key, encoded);
    }
    /**
     * Retrieve and decode data
     * @param key Storage key
     * @param parseJson Whether to parse as JSON (default: true)
     */
    async getItem(key, parseJson = true) {
        const encoded = await this.storage.getItem(key);
        return Base64Utils.safeDecode(encoded, parseJson);
    }
    /**
     * Remove item from storage
     * @param key Storage key
     */
    async removeItem(key) {
        await this.storage.removeItem(key);
    }
    /**
     * Clear all storage
     */
    async clear() {
        await this.storage.clear();
    }
    /**
     * Store raw Base64 data (for manual encoding)
     * @param key Storage key
     * @param base64Value Base64 encoded string
     */
    async setRaw(key, base64Value) {
        await this.storage.setItem(key, base64Value);
    }
    /**
     * Get raw Base64 data (without decoding)
     * @param key Storage key
     */
    async getRaw(key) {
        return await this.storage.getItem(key);
    }
}
/**
 * Enhanced Creation Storage with Base64 utilities
 */
class R1Storage {
    /**
     * Plain storage (unencrypted, Base64 encoded)
     */
    get plain() {
        if (!this._plain) {
            if (!window.creationStorage?.plain) {
                throw new Error('Plain storage not available. Make sure you are running in R1 environment.');
            }
            this._plain = new StorageWrapper(window.creationStorage.plain);
        }
        return this._plain;
    }
    /**
     * Secure storage (hardware-encrypted, Base64 encoded)
     * Requires Android M or higher
     */
    get secure() {
        if (!this._secure) {
            if (!window.creationStorage?.secure) {
                throw new Error('Secure storage not available. Make sure you are running on Android M+ in R1 environment.');
            }
            this._secure = new StorageWrapper(window.creationStorage.secure);
        }
        return this._secure;
    }
    /**
     * Check if storage is available
     */
    static isAvailable() {
        return typeof window !== 'undefined' && !!window.creationStorage;
    }
    /**
     * Check if secure storage is available
     */
    static isSecureAvailable() {
        return this.isAvailable() && !!window.creationStorage.secure;
    }
    /**
     * Utility to store user preferences with type safety
     * @param prefs User preferences object
     * @param useSecure Whether to use secure storage (default: false)
     */
    async setPreferences(prefs, useSecure = false) {
        const storage = useSecure ? this.secure : this.plain;
        await storage.setItem('user_preferences', prefs);
    }
    /**
     * Utility to get user preferences with type safety
     * @param useSecure Whether to use secure storage (default: false)
     */
    async getPreferences(useSecure = false) {
        const storage = useSecure ? this.secure : this.plain;
        return await storage.getItem('user_preferences');
    }
    /**
     * Utility to store sensitive data (API keys, tokens, etc.)
     * @param key Storage key
     * @param value Sensitive data
     */
    async setSecret(key, value) {
        await this.secure.setItem(`secret_${key}`, value);
    }
    /**
     * Utility to get sensitive data
     * @param key Storage key
     */
    async getSecret(key) {
        return await this.secure.getItem(`secret_${key}`, false);
    }
}
exports.R1Storage = R1Storage;
// Export singleton instance
exports.storage = new R1Storage();
//# sourceMappingURL=index.js.map